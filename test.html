<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Simulation Engine Verification</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #222;
            color: #eee;
        }

        .pass {
            color: #4ade80;
            font-weight: bold;
        }

        .fail {
            color: #f87171;
            font-weight: bold;
        }

        .info {
            color: #94a3b8;
        }
    </style>
    <script src="js/statistics.js"></script>
    <script src="js/engine.js"></script>
</head>

<body>
    <h1>Verification Results</h1>
    <div id="logs"></div>

    <script>
        const logDiv = document.getElementById('logs');
        function log(msg, type = '') {
            const div = document.createElement('div');
            div.textContent = msg;
            if (type) div.className = type;
            logDiv.appendChild(div);
        }

        function runTests() {
            log("Initializing Test Configuration...", "info");

            // --- UNIT TEST STATS ---
            log("Running Unit Tests for Statistics.js...", "info");

            // 1. Test randomNormal Mean/Std
            let sum = 0, sumSq = 0;
            const N = 100000;
            for (let i = 0; i < N; i++) {
                let r = Stats.randomNormal(0, 1);
                sum += r;
                sumSq += r * r;
            }
            const mean = sum / N;
            const variance = (sumSq / N) - (mean * mean);
            const std = Math.sqrt(variance);

            log(`randomNormal(0,1) -> Mean: ${mean.toFixed(4)} (Exp 0), Std: ${std.toFixed(4)} (Exp 1)`, Math.abs(mean) < 0.05 && Math.abs(std - 1) < 0.05 ? "pass" : "fail");

            // 2. Test normPPF
            const p50 = Stats.normPPF(0.5);
            const p975 = Stats.normPPF(0.975);
            const p025 = Stats.normPPF(0.025);

            log(`normPPF(0.5) = ${p50.toFixed(4)} (Exp 0.0000)`, Math.abs(p50) < 0.001 ? "pass" : "fail");
            log(`normPPF(0.975) = ${p975.toFixed(4)} (Exp 1.9600)`, Math.abs(p975 - 1.96) < 0.01 ? "pass" : "fail");
            log(`normPPF(0.025) = ${p025.toFixed(4)} (Exp -1.9600)`, Math.abs(p025 + 1.96) < 0.01 ? "pass" : "fail");

            // --- END UNIT TESTS ---

            const configs = {
                numSims: 10000,
                years: 30,
                INVESTED_AMOUNT: 1000000,
                CASH_BUFFER: 0,
                allocCrypto: 0,
                allocStocks: 1, // 100% Stocks

                INFL_MEAN: 0.025,
                INFL_VOL: 0.015,

                CORR_START: 0, CORR_END: 0,
                C_CAGR_START: 0.32, C_CAGR_END: 0.08,
                C_VOL_START: 0.40, C_VOL_END: 0.20,

                S_CAGR_START: 0.08, S_CAGR_END: 0.06,
                S_VOL_START: 0.18, S_VOL_END: 0.16,

                TARGET_ANNUAL_EXP: 0,
                FLOOR_MULT: 0,
                CEILING_EARLY: 100,
                CEILING_LATE: 100,
                FORCE_CRASH: false,
                MAX_BAD_YEARS: 100
            };

            // Map legacy props if needed
            configs.ALLOC_CRYPTO = configs.allocCrypto;
            configs.ALLOC_STOCKS = configs.allocStocks;

            log(`Running ${configs.numSims} Simulations for 30 Years...`, "info");
            log(`Assumptions: Stock Returns 6-8%, Vol 16-18%, Inflation 2.5%`, "info");

            const startTime = performance.now();
            const marketData = generateMarketData(configs.numSims, configs.years, configs);
            log(`Market Data Generated in ${(performance.now() - startTime).toFixed(0)}ms`, "info");

            // --- UNIT MOCK: DETERMINISTIC MATH CHECK ---
            log("Running Deterministic Math Check (Vol=0, Inf=0)...", "info");

            // Theory: 5% Real Return, 30 Years, Exhaust Capital exactly.
            // Solving for PMT (Annual Withdrawal Rate).
            // Formula (Monthly): W_mo = PV * r_mo / (1 - (1+r_mo)^-n)

            const rAnnual = 0.05;
            const rMo = Math.pow(1 + rAnnual, 1 / 12) - 1;
            const months = 30 * 12;
            const pmtFactor = rMo / (1 - Math.pow(1 + rMo, -months));
            const theorySWR = pmtFactor * 12; // Annualized rate

            log(`Theoretical Max SWR (5% Real, 30y): ${(theorySWR * 100).toFixed(4)}%`);

            const configDet = {
                numSims: 1, years: 30, INVESTED_AMOUNT: 1000000,
                S_CAGR_START: 0.05, S_VOL_START: 0, // 5% Deterministic
                INFL_MEAN: 0, INFL_VOL: 0 // 0% Inflation
            };
            const marketDet = generateMarketData(1, 30, configDet);

            // Binary search for simulation SWR
            function findSWRDeterministic(data, cfg) {
                let low = 0.01, high = 0.10, best = 0.0;
                for (let i = 0; i < 30; i++) {
                    let mid = (low + high) / 2;
                    const res = simulatePortfolio(mid, data, cfg);
                    if (res.successRate >= 0.99) { best = mid; low = mid; }
                    else { high = mid; }
                }
                return best;
            }

            const simSWR = findSWRDeterministic(marketDet, configDet);
            log(`Simulation SWR: ${(simSWR * 100).toFixed(4)}%`);

            const diff = Math.abs(simSWR - theorySWR);
            if (diff < 0.001) { // 0.1% tolerance
                log(`[PASS] Engine matches Math Formula (Diff: ${(diff * 100).toFixed(4)}%)`, "pass");
            } else {
                log(`[FAIL] Engine Math Error. Diff: ${(diff * 100).toFixed(4)}%`, "fail");
            }

            // --- END DETERMINISTIC CHECK ---

            // DEBUG: Check for NaNs and Extremes
            let nanCount = 0;
            let minRet = 1000, maxRet = -1000;
            let sumRet = 0;
            const stocksMap = marketData.stocks;
            const totalPoints = stocksMap.length;

            for (let i = 0; i < totalPoints; i++) {
                if (isNaN(stocksMap[i])) nanCount++;
                else {
                    if (stocksMap[i] < minRet) minRet = stocksMap[i];
                    if (stocksMap[i] > maxRet) maxRet = stocksMap[i];
                    sumRet += stocksMap[i];
                }
            }

            const meanLogRet = sumRet / (totalPoints - nanCount);

            // Expected Mean (Monthly)
            // S_CAGR (Annual) -> Monthly Drift
            const expectedMeanMo = Math.log(1 + configs.S_CAGR_START) / 12;
            log(`Mean Log Return (Mo): ${meanLogRet.toFixed(5)} (Expected ~${expectedMeanMo.toFixed(5)})`, "info");
            log(`NaN Count in Stock Returns: ${nanCount}`, nanCount > 0 ? "fail" : "pass");
            log(`Min Log Return: ${minRet.toFixed(4)} (${(Math.exp(minRet) - 1) * 100}%)`, "info");
            log(`Max Log Return: ${maxRet.toFixed(4)} (${(Math.exp(maxRet) - 1) * 100}%)`, "info");

            if (nanCount > 0) {
                log("CRITICAL: NaNs detected. Aborting test.", "fail");
                return;
            }

            // DEBUG: Trace one simulation to see why it fails
            function debugOneRun(rate, data, cfg) {
                log(`\n--- DEBUG TRACE (Rate: ${(rate * 100).toFixed(1)}%) ---`, "info");
                const { years } = cfg;
                const months = years * 12;
                const s = 0; // Trace Sim 0

                let portfolio = cfg.INVESTED_AMOUNT;
                let annualWithdrawal = cfg.INVESTED_AMOUNT * rate;
                let monthlyWithdrawal = annualWithdrawal / 12;

                let accumInf = 1.0;

                log(`Start: P=${portfolio}, AnnualWD=${annualWithdrawal}`);

                for (let m = 0; m < Math.min(months, 120); m++) { // First 120 months
                    const idx = s * months + m;
                    const rLog = data.stocks[idx];
                    const infl = data.inflation[idx];

                    const rLin = Math.exp(rLog) - 1;
                    accumInf *= (1 + infl);

                    portfolio *= (1 + rLin);
                    portfolio -= monthlyWithdrawal;

                    portfolio = Math.max(0, portfolio);

                    // Log output at end of each year (Month 11, 23, etc)
                    if ((m + 1) % 12 === 0) {
                        const year = (m + 1) / 12;
                        log(`Y${year}: W/D_Mo=${monthlyWithdrawal.toFixed(0)}, End=${portfolio.toFixed(0)}`);

                        // Adjust WD
                        annualWithdrawal *= accumInf;
                        monthlyWithdrawal = annualWithdrawal / 12;
                        accumInf = 1.0;
                    }

                    if (portfolio <= 0) {
                        log(`--> BUSTED at Month ${m + 1}`, "fail");
                        break;
                    }
                }
            }

            // Run debug trace with 4%
            debugOneRun(0.04, marketData, configs);

            function findSWR(targetOdds, data, cfg) {
                let low = 0.001, high = 0.10, best = 0.001;
                for (let i = 0; i < 20; i++) {
                    let mid = (low + high) / 2;
                    const res = simulatePortfolio(mid, data, cfg);
                    if (res.successRate >= targetOdds) { best = mid; low = mid; }
                    else { high = mid; }
                }
                return best;
            }

            const swr95 = findSWR(0.95, marketData, configs);
            const swr99 = findSWR(0.99, marketData, configs);

            log("----------------------------------------");
            log(`[SKEWED/DEFAULT] SWR (95%): ${(swr95 * 100).toFixed(2)}% (Conservative Settings)`);
            log("----------------------------------------");

            // --- CONTROL TEST (NO SKEW / NORMAL DISTRIBUTION) ---
            log("Running Control Test (Skew = 0)...", "info");
            const configsControl = { ...configs, S_SKEW_START: 0, S_SKEW_END: 0 };
            const marketDataControl = generateMarketData(configs.numSims, configs.years, configsControl);

            // Quick Mean Check Control
            let sumRetC = 0;
            for (let i = 0; i < marketDataControl.stocks.length; i++) sumRetC += marketDataControl.stocks[i];
            const meanLogRetC = sumRetC / marketDataControl.stocks.length;
            log(`[CONTROL] Mean Log Return: ${meanLogRetC.toFixed(5)}`, "info");

            const swr95Control = findSWR(0.95, marketDataControl, configsControl);
            log(`[CONTROL] SWR (95%): ${(swr95Control * 100).toFixed(2)}%`);

            // --- CONTROL TEST (NO INFLATION VOLATILITY) ---
            log("Running Control Test (Infl Vol = 0)...", "info");
            const configsNoInflVol = { ...configsControl, INFL_VOL: 0 }; // Control (No Skew) + No Infl Vol
            const marketDataIV0 = generateMarketData(configs.numSims, configs.years, configsNoInflVol);
            const swrIV0 = findSWR(0.95, marketDataIV0, configsNoInflVol);
            log(`[NO INFL VOL] SWR (95%): ${(swrIV0 * 100).toFixed(2)}%`);

            // --- TRINITY BENCHMARK (50/50 Stocks/Bonds) ---
            // The "4% Rule" is derived from balanced portfolios (50/50 to 75/25).
            // 100% Stocks (16% Vol) often fails 4% rule in Monte Carlo (GBM).
            // Balanced Portfolio:
            // Return: ~8% Nominal (lower than 100% stock)
            // Volatility: ~10% (Much lower due to Bonds)
            // Inflation: 3%

            log("Running Trinity Benchmark (50/50 Balanced Portfolio)...", "info");
            const configsTrinity = {
                ...configsControl,
                // Mixed Return (8% Nominal)
                S_CAGR_START: 0.08, S_CAGR_END: 0.08,
                // Mixed Volatility (10% - Bonds smooth variance)
                S_VOL_START: 0.10, S_VOL_END: 0.10,
                INFL_MEAN: 0.03, INFL_VOL: 0.01
            };
            const marketDataTrinity = generateMarketData(configs.numSims, configs.years, configsTrinity);
            const swrTrinity = findSWR(0.95, marketDataTrinity, configsTrinity);
            log(`[TRINITY BALANCED] SWR (95%): ${(swrTrinity * 100).toFixed(2)}%`);

            // ASSERTIONS
            let passed = true;

            // 4% Rule Check on Balanced Data
            if (swrTrinity >= 0.038) {
                log(`[PASS] Trinity Balanced Benchmark SWR is ${(swrTrinity * 100).toFixed(2)}% (Matches 4% Rule)`, "pass");
            } else {
                log(`[FAIL] Trinity Balanced Benchmark SWR is too low: ${(swrTrinity * 100).toFixed(2)}%`, "fail");
                passed = false;
            }

            // Also check Deterministic Vol=0 again just to be safe
            if (swrIV0 >= 0.027) { // Just a sanity check that normal code runs
                // No op
            }

            if (swr95Control >= 0.035 && swr95Control <= 0.045) {
                log(`[PASS] Control (Normal Dist) SWR is within expected range (3.5% - 4.5%)`, "pass");
            } else {
                log(`[FAIL] Control (Normal Dist) SWR is OUTSIDE expected range. Got ${(swr95Control * 100).toFixed(2)}%`, "fail");
                log("Probable Cause: Basic Return/Vol logic is biased.", "fail");
                passed = false;
            }

            if (passed) {
                if (swr95 < 0.030) {
                    log("NOTE: Default Configs (6-8% Nom) yield lower SWR (${swr95*100}%) than History. This is expected given lower return assumptions.", "info");
                }
                log("VERIFICATION COMPLETE: Engine validates against Historical Benchmark.", "pass");
            } else {
                log("VERIFICATION FAILED: Engine fails even with high returns.", "fail");
            }
        }

        // Run automatically
        setTimeout(runTests, 500);
    </script>
</body>

</html>